面试准备：页面布局、CSS盒模型、DOM事件、HTTP协议、面向对象、原型链、通信、安全、算法。

一、页面布局
    题目：假设高度已知，请写出三栏布局，其中左栏、右栏各为300px，中间自适应。
    (常见方案：浮动布局、绝对布局、flexbox布局、表格布局、网格布局)

    延伸：1.这5种方案各自有什么优点和缺点？
         2.如果高度未知，使每栏高度随内容自动撑开，且高度一致，该5种方案还有哪几个还可以适用？哪几个已经不能用了？
         3.这5种方案的兼容性如何？如果在业务开发中给你选择，你的最优方案是哪种？

    1.答案：
        (1)浮动布局   缺点：浮动后元素脱离文档流，如果处理不好会带来很多问题。
                     优点：如果做好清除浮动及处理好浮动周边的元素的关系，兼容性比较好。
        (2)绝对布局   缺点：布局已经脱离文档流，意味着下面的子元素也脱离了文档流，这导致有效性及可使用性比较差。
                     优点：快捷，如果配合js使用，非常快，也不容易出问题。
        (3)flex布局   为解决上述两种方案产生的不足而设计的，相对来说比较完美，在移动端上基本都是flex布局。
        (4)表格布局   缺点：比较麻烦；操作比较繁琐；对SEO不够友好；当其中一个单元格的高度超出的时候，
                           其他两个单元格也需要跟着相应改变，在某些业务场景中是不需要自动增高的。
                     优点：兼容性比较好，如果在PC上需要兼容比较低版本的IE8，flex布局不能实现，表格布局可以实现
        (5)网格布局   网格布局可以做很多复杂的事情，但是代码量要简化很多，网格布局也是一种新的技术

    2.答案：flex布局和表格布局还适用。其他三种均超出。
      延伸：(1)浮动布局中，为什么中间部分的内容超出后会在左栏下面显示？
              原因：这是因为浮动的基本原理。中间的内容向左浮动的时候，被左侧的块挡住了，所以文字在中间显示；
                    当内容超出以后，发现左侧没有遮挡物，所以文字会在左侧的块的下边显示。
              延伸：如果需要让中间的内容即使超出后也只在中间部分展示，不能跑到左右侧下方，如何实现？ 答案：创建BFC

    页面布局的变通：
        三栏布局：左右宽度固定，中间自适应
                 上下高度固定，中间自适应
        两栏布局：左宽度固定，右自适应
                 右宽度固定，左自适应
                 上高度固定，下自适应
                 下高度固定，上自适应

二、CSS盒模型
    1.CSS模型有两种：标准模型和IE模型。

    2.标准模型和IE模型区别？
        标准模型：内容的宽度不包含 padding 和 border
        IE模型：内容的宽度包含 padding 和 border

    3.CSS如何设置这两种模式？
        box-sizing: content-box; 标准模式
        box-sizing: border-box; IE模式
        浏览器默认的是content-box，即标准模式
    
    4.JS如何设置获取盒模型对应的宽和高
        dom.style.width/height：只能取到内联样式的宽和高

        dom.currentStyle.width/height：拿到的是渲染后的宽和高，相对比较准确，这个宽和高是样式定义的宽高，
                                       如果样式没有设定，那么获取到的宽高都是auto，但是只有IE支持。

        window.getComputedStyle(dom).width/height：通用性更好，兼容火狐谷歌，IE8及IE8以下不支持，
                                                   获取的宽度和高度随浏览器设置的不同盒模型而变化。

        dom.getBoundingClientRect().width/height：也能拿到元素真实的宽和高，适用场景是计算元素的绝对位置。
                                                  这个绝对位置是针对屏幕左上角(0,0)的绝对位置，该方法拿到的是6个值，
                                                  left/top/right/bottom/width/height。IE8及IE8以下只能拿到4个值上下左右，没有宽和高。

    5.实例题(边距重叠)
        (1)BFC的基本概念：块级格式化上下文
        (2)BFC的原理(BFC的渲染规则)：
            a.在BFC这个元素的垂直方向上的边距会发生重叠；
            b.BFC的区域不会与浮动元素的box重叠；
            c.BFC在页面上是一个独立的容器，外面的元素不会影响它里面的元素；反过来，里面的元素也不会影响外面的元素；
            d.计算BFC高度的时候，其内部的浮动元素也会参与计算。
        (3)如何创建BFC？
            a.float值不为none；
            b.position的值不为static或者relative；
            c.display的值是inline-block、table-cell、flex、table-caption或者inline-flex；
            d.overflow不为visible。
        (4)BFC的使用场景有哪些？
            解决边距重叠、清除浮动

三、DOM事件
    1.DOM事件的级别：实际上是DOM标准定义的级别。
        DOM0    element.onclick = function(){}
        DOM2    element.addEventListener('click', function(){}, false)
        DOM3    element.addEventListener('keyup', function(){}, false)
        说明：DOM1设计的时候，没有设计跟事件相关的东西，所以事件级别会直接从DOM0跳到DOM2。
    
    2.DOM事件模型：捕获和冒泡
    
    3.DOM事件流
        浏览器在为当前这个页面与用户做交互的过程中，例如点击鼠标左键，这个动作是怎么传递到页面上，这就是事件流。
        一个完整的事件流分三个阶段：捕获阶段，目标阶段，冒泡阶段。
    
    4.描述DOM事件捕获的具体流程
        window => document => html => body => ... => 目标元素
        JS中获取html节点：document.documentElement
        JS中获取body节点：document.body
    
    5.Event对象的常见应用
        event.preventDefault()
        event.stopPropagation()
        event.stopImmediatePropagation()
        event.currentTarget
        event.target
    
    6.自定义事件(模拟事件)
        使用场景：有一个按钮，不是一个常规的click事件，给这个按钮增加一个自己的事件，并且可以在其他地方触发这个事件，
                 而不是用回调的方式触发，这个时候就可以用自定义事件。
        var eve = new Event('custome'); // 将eve当成普通事件对象
        ev.addEventListener('custome', function(){
          console.log('custome');
        });
        ev.dispatchEvent(eve);
        此时就完成了一个自定义事件和自定义触发事件的过程

四、HTTP协议类
    1.HTTP协议的主要特点
        简单快速：每个资源URI是固定的，想访问某个资源只需要输入URI就可以了。
        灵活：在HTTP协议头部会有一个数据类型，通过一个HTTP协议就可以完成不同数据类型的传输。
        无连接：连接一次就会断掉，不会保持连接。
        无状态：客户端和服务端是两种身份，客户端下次请求的资源即使和上次一样，服务端也不会记住是哪个用户请求了哪些资源。
    
    2.HTTP报文的组成部分
        请求报文：请求行、请求头、空行、请求体。
            请求行：HTTP方法、页面地址（请求URL）、HTTP协议、HTTP版本
            请求头：一些key value值，来告诉服务端客户端需要哪些内容，要注意哪些类型。
            空行：告诉服务端请求头到此结束，后面的内容是请求体。
            请求体：
        响应报文：状态行、响应头、空行、响应体。
            响应报文的组成部分描述基本与请求报文一致。

    3.HTTP方法(面试中这5种方法都要说出来)
        GET     获取资源
        POST    传输资源
        PUT     更新资源
        DELETE  删除资源
        HEAD    获得报文首部

    4.POST和GET的区别
        (1) GET 在浏览器回退时是无害的，而 POST 会再次提交请求 (重要)
        (2) GET 产生的URL地址可以被收藏，而 POST 不可以
        (3) GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置 (重要)
        (4) GET 请求只能进行url编码，而 POST 支持多种编码方式
        (5) GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留 (重要)
        (6) GET 请求在URL中传送的参数是有长度限制的，而 POST 没有限制 (重要)
        (7) 对参数的数据类型，GET 只接受 ASCII字符，而 POST 没有限制
        (8) GET 比 POST 更不完全，因为参数直接暴露在URL上，所以不能用来传递敏感信息
        (9) GET 参数通过URL传递，POST 放在Request body中 (重要)

    5.HTTP状态码
        1xx：指示信息----表示请求已接收，继续处理
        2xx：成功--------表示请求已被成功接收
        3xx：重定向------要完成请求必须进行更进一步的操作
        4xx：客户端错误--请求有语法错误或请求无法实现
        5xx：服务器错误--服务器未能实现合法的请求

        200 OK：客户端请求成功
        206 Partial Content：客户发送了一个带有Range头的GET请求，服务器完成了它
        301 Moved Permanently：所请求的页面已经转移至新的url
        302 Found：所请求的页面已经临时转移至新的url
        304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用
        400 Bad Request：客户端请求有语法错误，不能被服务器所理解
        401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
        403 Forbidden：对被请求页面的访问被禁止
        404 Not Found：请求资源不存在
        500 Internal Server Error：服务器发生不可预期的错误，原来缓存的文档还可以继续使用
        503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常
    
    6.什么是持久连接
        HTTP协议采用“请求--应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要重新建一个连接，完成之后立即断开连接(HTTP协议为无连接的协议)。

        当使用 Keep-Alive 模式(又称持久连接、连接重用)时， Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时， Keep-Alive 功能避免了简历或者重新简历连接。
    
    7.什么是管线化
        在使用持久连接的情况下，某个连接上消息的传递类似于
        请求1 -> 响应1 -> 请求2 -> 响应2 -> 请求3 -> 响应3

        某个连接上的消息变成了类似这样
        请求1 -> 请求2 -> 请求3 -> 响应1 -> 响应2 -> 响应3

        (1)管线化机制通过持久连接完成，仅 HTTP/1.1 支持此技术 (重要)
        (2)只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制 (重要)
        (3)初次创建连接时不应启动管线机制，因为对方(服务器)不一定支持 HTTP/1.1 版本的协议 (重要)
        (4)管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
        (5)HTTP/1.1 要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可
        (6)由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，
           因此现代浏览器如 Chrome 和 Firefox 默认并未开启管线化支持


五、原型链
    1.创建对象有几种方法
        (1)使用对象字面量创建对象
            var o1 = { name: 'o1'};
            var o11 = new Object({ name: 'o11'});

        (2)使用显示的构造函数创建对象
            var M = function(){
                this.name = 'o2';
            }
            var o2 = new M();

        (3)使用Object.create创建空对象
            var P = { name: 'o3'};
            var o3 = Object.create(P);

    2.原型、构造函数、实例、原型链
        构造函数 可以使用 new 运算符来生成一个实例 ，构造函数也是函数(任何函数都可以用来当做构造函数；用了 new 就是构造函数，不用就是普通函数)；
        函数都有一个 prototype 属性(这是在声明一个函数的时候，JS自动给它加上的属性)，这个 prototype 指的就是原型对象；
        原型对象中会有一个构造器 constructor ，这个构造器会默认你声明的那个函数；
        实例上的 __proto__ 属性引用的是构造函数的原型对象，也就是 实例.__proto__ === 构造函数.prototype。

        原型链：从一个实例往上找构造这个实例的相关联的对象，然后这个对象再往上找，它又有创造它的上一级的原型对象，以此类推，
               一直到 Object.prototype 原型对象，终止，此时这个链条就断了。也就是说 Object.prototype 是这个原型链的顶端。
               原型链是通过 prototype 原型和 __proto__ 属性来完成原型链的查找。

               通过原型链的方式，找到原型对象，这样的方法是被不同的实例所共有的；
               在访问一个实例的时候，在实例上没有找到这个方法或属性，它会往它的原型对象(__proto__)上找，
               如果在它的上一级还没有找到它的属性或方法，它会在它原型对象的基础上，再通过原型对象的 __proto__ 属性再向上查找；
               依次类推，直到找到 Object.prototype ，要是在这个地方还没有找到，原路返回，告诉它这个属性或方法没有找到，没有定义；
               如果查找过程中在某一处找到这个属性或方法，它就停止向上查找。

        注意：
            函数才会有 prototype 属性，对象没有 prototype；
            只有实例对象有 __proto__(函数也是对象，所以函数也会有 __proto__ 属性)。

    3.instanceof的原理
        看图(../img/原型链4--instanceof.png)
        instanceof 的原理就是来判断实例对象的 __proto__ 属性和构造函数的 prototype 属性，判断是不是同一个引用(是否引用同一个地址)；
        当原型对象上还有它自己的 __proto__ ，有它自己的构造函数的原型对象，依次类推往上走，在 instanceof 判断的时候，
        只要在这条原型链上，构造函数都是这个实例的一个构造函数，这样说实际上不严谨，但是 instanceof 都会返回true。

        用 constructor 来判断实例是哪个构造函数的实例。
        实例.__proto__.constructor === M  true
        实例.__proto__.constructor === Object  false

    4.new运算符
        一个新对象被创建。它继承自 foo.prototype
        ||
        构造函数 foo 被执行。执行的时候，相应的传参会被传入，同时上下文(this)会被指定为这个新实例。new foo 等同于 new foo()，只能用在不传递任何参数的情况
        ||
        如果构造函数返回了一个“对象”，那么这个对象会取代整个 new 出来的结果。如果构造函数没有返回对象，那么 new 出来的结果为步骤1创建的对象


六、面向对象
    1.类与实例
        (1)类的声明
        (2)生成实例
    2.类与继承
        (1)如何实现继承
        (2)继承的几种方式


七、通信
    1.什么是同源策略及限制
        源：协议、域名、端口
        概念：同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的关键的安全机制。
        限制：(1)Cookie、Localstorage、IndexDB无法读取
              (2)DOM无法获取
              (3)Ajax请求不能发送(ajax只适合同源通信)

    2.前后端如何通信
        (1)Ajax(同源通信方式)
        (2)WebSocket(不限制同源策略)
        (3)CORS(支持跨域通信，也支持同源通信)

    3.如何创建Ajax
        (1)XMLHttpRequest 对象的工作流程
        (2)兼容性处理
        (3)事件的触发条件
        (4)事件的触发顺序

    4.跨域通信的几种方式(一定都要说出来)
        (1) jsonp
            问题：jsonp的原理是什么，怎么实现的？如果让你来实现，你怎么实现？
            原理：动态创建script标签，使用script标签的异步加载来实现。

        (2) Hash(url中#后面的改变，页面并没有刷新；url中?后面的改变页面会刷新，所以search不能做跨域通信)
        (3) postMessage
        (4) WebSocket
        (5) CORS(可以理解为支持跨域通信的ajax，浏览器在识别用户用ajax发送了一个跨域请求的时候，它会在http头中加Origin来允许跨域通信)

八、安全
    1.CSRF
        (1)基本概念和缩写
            CSRF，通常称为跨站请求伪造，英文名 Cross-site request forgery，缩写CSRF
        (2)攻击原理
            原理：用户在A网站中注册并登录过，登录成功后，A网站会向用户的浏览器下发cookie。
                 随后用户又访问了B网站，B网站下发页面的时候会存在一个引诱的点击，这个点击往往是一个链接，这个链接指向了网站A的一个API接口，尤其这个API接口是get类型。
                 当用户禁不住诱惑点击了这个接口，这个点击就访问到了A网站，此时浏览器会自动上传cookie，A网站接收到cookie，对用户身份进行了确认，发现是合法用户，它就执行了这个接口的动作。
            造成CSRF攻击需要的因素：
                a.网站中某个接口存在这种漏洞
                b.用户一定在注册网站登录过
        (3)防御措施
            a.Token验证(登录注册后服务器会在浏览器本地存储一个token，在访问各种接口的时候，如果没有带这个token，服务器就不通过验证。像引诱点击链接，只会携带cookie，不会携带token。因此这种方式就避免了攻击)
            b.Referer验证(页面来源，如果服务器判断当前来源是否是这个站点下面的页面，如果是的话执行这个动作，不是的话一律拦截)
            c.隐藏令牌(与token有点像。隐藏在http head头中，不会放在链接上，这样就会做得比较隐蔽)
    2.XSS(XSS是向页面中注入JS去运行)
        (1)攻击原理
        (2)防御措施

    延伸：
    3.前端cookies安全性
    4.点击劫持
    5.传输过程安全问题
    6.用户密码安全问题(后端相关)
        (1)SQL注入攻击
        (2)信息泄露和社会工程学

九、算法
    1.排序
        快速排序：https://segmentfault.com/a/1190000009426421
        选择排序：https://segmentfault.com/a/1190000009366805
        希尔排序：https://segmentfault.com/a/1190000009461832
        冒泡排序：
    2.堆栈、队列、链表
        堆栈：https://juejin.im/entry/58759e79128fe1006b48cdfd
        队列：https://juejin.im/entry/58759e79128fe1006b48cdfd
        链表：https://juejin.im/entry/58759e79128fe1006b48cdfd
    3.递归    https://segmentfault.com/a/1190000009857470
    4.波兰式和逆波兰式
        理论：http://www.cnblogs.com/chenying99/p/3675876.html
        源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js

十、渲染机制
    1.什么是 DOCTYPE 及作用
        DTD(document type definition，文档类型定义)是一系列的语法规则，用来定义XML或(X)HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器模式(DTD就是告诉浏览器我是什么文档类型，浏览器根据这个判断需要用什么浏览器引擎来解析渲染)。
        DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出一些差错(DOCTYPE就是直接告诉浏览器当前的文档是哪个DTD，也就是哪个文档类型)。

        追问：常见的DOCTYPE有哪些？HTML5的DOCTYPE如何写？
        HTML5：<!DOCTYPE html>
        HTML4.01 Strict 该DTD包含所有HTML元素和属性，但不包括展示性和弃用的元素(比如font)
        HTML4.01 Transitional 该DTD包含所有HTML元素和属性，包括展示性和弃用元素(比如font)
    
    2.浏览器渲染过程 (看图(../img/渲染机制--浏览器渲染过程.png))
        浏览器拿到 HTML 和 CSS 要干什么？
        (1) HTML 经过 HTML Parser(HTML解析器) 转成 DOM Tree(即DOM树)；CSS 经过 CSS 规则和 CSS Parser(CSS解析器) 转成 CSSOM Tree；
            
        (2)之后这两棵树之间进行整合(Attachment)，形成一棵Render Tree，此时类似于告诉浏览器这个地方要渲染的一棵树的结构已经基本出来了；
           Render Tree 不包含 HTML 的具体内容，它也不知道这个具体位置是什么，也就是在 Layout 之前，有一个div，Render Tree并不知道这个div的具体位置；
           通过 Layout 才可以具体知道要显示的这些 DOM 具体的宽高、颜色都在 Render Tree 呈现出来；

        (3)最后开始 Painting，浏览器通过 GUX 开始画图，把我们的内容基本呈现出来；最后 Display 就是大家在浏览器上能看到整个页面效果。

    3.重排 Reflow
        (1)定义：DOM结构中各个元素都有自己的盒子(模型)，这些都需要浏览器根据各种样式来计算，并根据计算结果将元素放到它该出现的位置，这个过程称为 Reflow。

        (2)触发Reflow的几种方式：
            (a)当你增加、删除、修改DOM节点时，会导致 Reflow 或 Repaint；
            (b)当你移动DOM的位置，或是搞个动画的时候；
            (c)当你修改CSS样式的时候；
            (d)当你 Resize 窗口的时候(移动端没有这个问题)，或是滚动的时候；
            (e)当你修改网页的默认字体时(这样做会有一些性能问题，或者是大家能看到的那种闪)
        如何尽量避免Reflow？

    4.重绘 Repaint(Repaint无法避免，但是可以最大程度的降低Repaint)
        (1)定义：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器于是便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称为 Repaint。
        (2)触发Repaint的几种方式：DOM改动、CSS改动
        如何避免最小程度的Repaint？

    5.布局 Layout


十一、JS机制(运行机制类)
    console.log(1);
    setTimeout(function(){
      console.log(3);
    },0);
    console.log(2);

    问：最后的打印顺序是什么？
    答：1,2,3。JS是单线程的，即JS在同一时间只能做一件事。任务队列，同步任务和异步任务。setTimeout就是一个异步任务，异步任务要挂起；console.log，在script中的语句叫同步任务，


    console.log('A');
    while(true){

    }
    console.log('B');
    问：最后打印出什么？
    答：A。while是一个同步任务，它会不断循环，所以B不会被执行。


    console.log('A');
    setTimeout(function(){
      console.log('B');
    },0);
    while(true){

    }
    问：最后打印出什么？
    答：A。在同步任务(while)执行完之前，任何的异步任务都不会响应。


    for(var i = 0; i < 4; i++){
      setTimeout(function(){
        console.log(i);
      }, 1000);
    }
    问：console.log会输出几次？每次的执行结果是什么？
    答：for是一个同步任务，for循环在执行的过程中，遇到setTimeout，时间间隔是1000，
        定时器会记住这个语句，但是它没有立即去执行。也就是说for循环在执行过程中，
        并没有真正的放到任务队列中去，(异步任务的放入时间和执行时间)。
    
    1.如何理解JS的单线程？
    2.什么是任务队列？
    3.什么是 Event Loop？
    4.异步任务
        (1)setTimeout和setInterval
        (2)DOM事件：我们在执行DOM事件的时候，要用addEventListener注册一个类型的事件，那么这个浏览器会有一个单联的模块去接收这个东西，
                    当这个事件被触发的时候，也就是监听GUI线程，监听用户点了某个按钮，这个时候要触发这个事件，那么浏览器的某个模块就把
                    我们注册的那个函数体扔到异步队列中。如果浏览器现在的执行站是空的，它就去任务队列中拿到这个函数体，开始执行，也就是
                    我们注册事件中的那个响应函数。JS是单线程的，浏览器有同步任务在执行的时候，你点什么按钮，它也不会去读那个任务队列，
                    所以它就根本不会执行，你看到的就是浏览器卡住了。

        (3)ES6中的Promise

    总结：(1)理解JS的单线程的概念
         (2)理解任务队列
         (3)理解Event Loop
         (4)理解哪些语句会放入异步任务队列
         (5)理解语句放入异步任务队列的时机
        

十二、页面性能
    题目：提升页面性能的方法有哪些？
    1.资源压缩合并，并减少HTTP请求
    2.非核心代码异步加载 ==> 异步加载的方式 ==> 异步加载的区别
        (1)异步加载的方式
            (a)动态脚本加载
            (b)defer
            (c)async
        (2)异步加载的区别
            (a)defer 是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行
            (b)async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

    3.利用浏览器缓存 ==> 缓存的分类 ==> 缓存的原理
        (1)缓存的分类
            (a)强缓存(不管问不问，直接拿过来用)
                Expires         Expires:Thu,21 Jan 2017 23:39:02 GMT    (绝对时间)
                Cache-Control   Cache-Control:max-age=3600              (相对时间)
                如果这两个时间都下发，以后者为准，即Cache-Control，这是规定。

            (b)协商缓存(浏览器发现本地有这个资源副本，但是又不确定用不用它，所以先向服务器问一下，该资源要不要用，是否已过期)
                当强缓存失效，过期了，浏览器不知道这个资源是否还能用，所以会向服务器发送If-Modified-Since确认，
                其中 If-Modified-Since 的值是上次请求中服务器返回的 Last-Modified 的值。
                Last-Modified       服务器下发的时间
                If-Modified-Since   客户端携带的时间(这两个时间一样，是方便服务器做比较)

                对比哈希值
                Etag                服务器下发的时候，会给 Etag 值，当过了强缓存的时间，浏览器再向服务器请求询问该资源是否还可以用，
                                    浏览器会在HTTP中加 If-None-Match 值，该值与 Etag 值相同。
                If-None-Match

        (2)缓存的原理
            浏览器缓存说的就是这个资源文件在浏览器中存在的备份，也可以理解为副本(放在电脑磁盘上)。
            浏览器下次请求的时候，相当于是直接从磁盘读取，而不会再向服务器请求该资源的地址。
    4.使用CDN
    5.预解析DNS
        <meta http-equiv="x-dns-prefetch-control" content="on">
        页面中所有的a标签，在一些高级浏览器中是默认打开DNS预解析的，也就是不用加下面那段代码a标签也可以实现DNS预解析；
        但是如果这个页面是 HTTPS 协议，很多浏览器是默认关闭DNS预解析的。所以该段代码是强制打开DNS预解析。

        <link rel="dns-prefetch" href="//host_name_to_prefetch.com">

十三、错误监控
    两种问法：如何监控JS错误？如何保证你的产品质量？
    1.前端错误的分类
        (1)即时运行错误：代码错误
        (2)资源加载错误

    2.错误的捕获方式
        即时运行错误的捕获方式：
            (1) try...catch   
            (2)window.onerror(只能捕获即时运行错误，不能捕获资源加载错误。资源加载错误不会冒泡，所以这个方法监测不到)
        资源加载错误的捕获方式：
            (1)object.onerror(资源加载错误不会冒泡，但是捕获阶段可以监控到，所以第三种方法才可行)
            (2)performance.getEntries()(获取已加载资源的加载时长，未加载成功不会在这里出现，这是一种间接捕获资源加载错误的方法)
            (3)Error事件捕获
        延伸：跨域的js运行错误可以捕获吗，错误提示什么，应该怎么处理？
        答：可以捕获。错误信息是 Script error，因为已经跨域，出错文件拿不到，出错行号和列号都是0，错误详情null。
            1)在script标签增加 crossorigin属性(客户端)
            2)设置js资源响应头 Access-Control-Allow-Origin: *(服务端，*号也可以换成指定的域名)

    3.上报错误的基本原理
        (1)采用Ajax通信的方式上报
        (2)利用Image对象上报    (new Image()).src = 'http://baidu.com/tesjk?r=tksjk';


十四、业务能力
    1.业务能力(主动描述或被动询问)
        (1)我做过什么业务
        (2)负责的业务有什么业绩
        (3)使用了什么技术方案
        (4)突破了什么技术难点
        (5)遇到了什么问题
        (6)最大的收获是什么
    2.团队协作能力(主动描述)
        (1)
        (2)
        (3)
    3.事务推动能力
    4.带人能力
    5.其他能力